[[_git_branches_overview]]
=== Branches in a Nutshell

Um wirklich zu verstehen, wie die Branching-Funktionalität in Git umgesetzt wird, muss man zunächst einen Schritt zurück gehen und untersuchen, wie Git seine Daten speichert.

Wie in Kapitel <<_getting_started>> bereits gesagt wurde, speichert Git Daten nicht als Change Set oder in Form dateibasierter Änderungen (Diffs), sondern als eine Reihe von Snapshots.

Wenn man einen Commit ausführt, speichert Git ein Commit-Objekt, das einen Zeiger auf den Snapshot mit dem gespeicherten Inhalt enthält.
Dieses Objekt enthält außerdem den Namen des Autors, dessen E-Mail-Adresse, eine Commit-Beschreibung, und Zeiger auf den oder die Commits, die dem aktuellen Commit als Eltern-Commits (englisch _parent_) unmittelbar vorausgegangen sind. Der initiale Commit besitzt keinen Parent, ein normaler Commit besitzt einen Parent, und Commits, die aus einem Merge von zwei oder mehreren Branches hervorgegangen sind, besitzen entsprechend mehrere Parents.

Um dies bildlich zu veranschaulichen, stelle man sich vor, man initialisiert ein Verzeichnis mit drei Dateien, staged und committet diese.
Beim Hinzufügen zur Staging-Area wird für jede Datei eine Prüfsumme berechnet (der in <<_getting_started>> erwähnte SHA-1-Hash), wird eine Version der Datei im Git-Repository gespeichert (Git bezeichnet diese als Blob), und wird die Prüfsumme zur Staging-Area hinzugefügt.

[source,console]
----
$ git add README test.rb LICENSE
$ git commit -m 'The initial commit of my project'
----

Erzeugt man dann einen Commit mittels `git commit`, erstellt Git eine Prüfsumme von jedem Unterverzeichnis (in diesem Fall nur vom Hauptverzeichnis des Projekts) und speichert diese sogenannten Tree-Objekte (englisch _tree_, Baum) im Git-Repository.
Git erstellt dann weiter ein Commit-Objekt, welches sowohl die Metadaten enthält, als auch einen Zeiger auf den Verzeichnisbaum des Hauptverzeichnisses, damit dieser Snapshot bei Bedarf wiederhergestellt werden kann.(((git commands, commit)))

Das neue Git-Repository enthält nun fünf Objekte: einen Blob für die Inhalte jeder der drei Dateien, einen Tree, der die Inhalte des Verzeichnisses auflistet und angibt, welche Dateinamen als welcher Blob gespeichert sind, und einen Commit, der den Zeiger auf die Wurzel des Verzeichnisbaums und alle Metadaten des Commits enthält.

.Ein Commit und sein Tree
image::images/commit-and-tree.png[Ein Commit und sein Tree.]

Nimmt man nun Änderungen vor und committet erneut, speichert der nächste Commit einen Zeiger auf den Commit, der dem neuen unmittelbar vorausgegangen ist.

.Commits und ihre Parents
image::images/commits-and-parents.png[Commits und ihre Parents.]

Bei Git ist ein Branch ein leichtgewichtiger, beweglicher Zeiger auf einen dieser Commits.
Der standardmäßig vergebene Name für einen Branch in Git lautet `master`.
Beginnt man mit dem Erstellen von Commits, erhält man den `master`-Branch, der auf den zuletzt erstellten Commit zeigt.
Bei jedem Commit rückt dieser automatisch vor.

[NOTE]
====
Der ``master''-Branch ist kein besonderer Branch in Git.(((master)))
Er ist so gewöhnlich wie jeder andere Branch.
Der einzige Grund, weshalb nahezu jedes Repository einen besitzt, ist dass der `git init`-Befehl ihn standardmäßig erstellt und sich kaum jemand veranlasst sieht, den Namen zu ändern.
====

.Ein Branch und seine Commit-Historie
image::images/branch-and-history.png[Ein Branch und seine Commit-Historie.]

[[_create_new_branch]]
==== Einen neuen Branch erzeugen

(((branches, creating)))
Was passiert, wenn man einen neuen Branch erzeugt?
Es wird ein neuer Zeiger erzeugt, den man bewegen kann.
Angenommen, man erstellt einen neuen Branch mit dem Namen testing.
Man erreicht dies, indem man den `git branch`-Befehl ausführt:(((git commands, branch)))

[source,console]
----
$ git branch testing
----

Damit wird ein neuer Zeiger erstellt, der auf den selben Commit zeigt, auf dem man sich gerade befindet.

.Zwei Branches, die auf dieselbe Reihe Commits zeigen
image::images/two-branches.png[Zwei Branches, die auf dieselbe Reihe Commits zeigen.]

Woher weiß Git, auf welchem Branch man sich gerade befindet?
Es führt einen besonderen Zeiger mit dem Namen `HEAD`.
Es gilt zu beachten, dass dies sich stark von dem Konzept eines `HEAD` in anderen Versionsverwaltungssystemen unterscheidet, die man vielleicht schon kennt, wie z.B. Subversion oder CVS.
Bei Git handelt es sich dabei um einen Zeiger auf den lokalen Branch, auf dem man sich zurzeit befindet.
In diesem Fall befindet man sich immer noch auf `master`.
Der `git branch`-Befehl hat lediglich einen neuen Branch _erzeugt_ – er sorgte nicht dafür, dass man auf diesen wechselt.

.HEAD zeigt auf einen Branch
image::images/head-to-master.png[HEAD zeigt auf einen Branch.]

Man kann dies leicht erkennen, indem man einen einfachen `git log`-Befehl ausführt, der einem mitteilt, wohin die Branch-Zeiger zeigen.
Diese Option wird `--decorate` genannt.


[source,console]
----
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to the central interface
34ac2 Fixed bug #1328 - stack overflow under certain conditions
98ca9 The initial commit of my project
----

Man sieht die Branches ``master'' und ``testing'', die sich beim Commit `f30ab` befinden.

[[_switching_branches]]
==== Branches wechseln

(((branches, switching)))
Um auf einen existierenden Branch zu wechseln, führt man den Befehl `git checkout` aus.(((git commands, checkout)))
Zum neuen Branch `testing` wechseln:

[source,console]
----
$ git checkout testing
----

Dadurch wurde `HEAD` verschoben und zeigt nun auf den Branch `testing`.

.HEAD zeigt auf den momentanen Branch
image::images/head-to-testing.png[HEAD zeigt auf den momentanen Branch.]

Was bringt dies zum Ausdruck?
Nun, es soll ein neuer Commit erzeugt werden:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made a change'
----

.Der HEAD-Branch bewegt sich vorwärts, wenn ein Commit erstellt wurde
image::images/advance-testing.png[Der HEAD-Branch bewegt sich vorwärts, wenn ein Commit erstellt wurde.]

Das Interessante daran ist, dass nun der Branch `testing` vorwärts bewegt wurde, der Branch `master` jedoch noch immer auf den Commit zeigt, auf dem man sich befand, als man `git checkout` ausgeführt hatte, um den Branch zu wechseln.
Wechselt man nun zurück auf den Branch `master`:

[source,console]
----
$ git checkout master
----

.HEAD moves when you checkout
image::images/checkout-master.png[HEAD moves when you checkout.]

That command did two things.
It moved the HEAD pointer back to point to the `master` branch, and it reverted the files in your working directory back to the snapshot that `master` points to.
This also means the changes you make from this point forward will diverge from an older version of the project.
It essentially rewinds the work you've done in your `testing` branch so you can go in a different direction.

[NOTE]
.Switching branches changes files in your working directory
====
It's important to note that when you switch branches in Git, files in your working directory will change.
If you switch to an older branch, your working directory will be reverted to look like it did the last time you committed on that branch.
If Git cannot do it cleanly, it will not let you switch at all.
====

Let's make a few changes and commit again:

[source,console]
----
$ vim test.rb
$ git commit -a -m 'made other changes'
----

Now your project history has diverged (see <<divergent_history>>).
You created and switched to a branch, did some work on it, and then switched back to your main branch and did other work.
Both of those changes are isolated in separate branches: you can switch back and forth between the branches and merge them together when you're ready.
And you did all that with simple `branch`, `checkout`, and `commit` commands.

[[divergent_history]]
.Divergent history
image::images/advance-master.png[Divergent history.]

You can also see this easily with the `git log` command.
If you run `git log --oneline --decorate --graph --all` it will print out the history of your commits, showing where your branch pointers are and how your history has diverged.

[source,console]
----
$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature #32 - ability to add new formats to the
* 34ac2 fixed bug #1328 - stack overflow under certain conditions
* 98ca9 initial commit of my project
----

Because a branch in Git is actually a simple file that contains the 40 character SHA-1 checksum of the commit it points to, branches are cheap to create and destroy.
Creating a new branch is as quick and simple as writing 41 bytes to a file (40 characters and a newline).

This is in sharp contrast to the way most older VCS tools branch, which involves copying all of the project's files into a second directory.
This can take several seconds or even minutes, depending on the size of the project, whereas in Git the process is always instantaneous.
Also, because we're recording the parents when we commit, finding a proper merge base for merging is automatically done for us and is generally very easy to do.
These features help encourage developers to create and use branches often.

Let's see why you should do so.
