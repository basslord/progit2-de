=== Grundlagen von Git

Nun, was also ist Git in aller Kürze?
Es ist äußerst wichtig, den folgenden Abschnitt gut zu verinnerlichen. Denn wenn man verstanden hat, was Git ist und wie seine zugrunde liegenden Konzepte funktionieren, ist es sehr gut möglich, das einem die effektive Verwendung von Git sehr viel leichter fallen.

Während des Kennenlernens von Git sollte man versuchen, vorhandenes Wissen über andere Versionsverwaltungssysteme (wie Subversion oder Perforce) über Bord zu werfen; dies wird bei der Benutzung von Git helfen, leichte Verwirrungen zu vermeiden.
Auch wenn das Benutzerinterface recht ähnlich aussieht, unterscheidet Git sich sehr von diesen anderen Systemen, was das Speichern von Informationen betrifft und wie es diese sieht; diese Unterschiede zu verstehen, hilft bei der Vermeidung von Verwirrungen bei der Benutzung.(((Subversion)))(((Perforce)))

==== Snapshots, keine Diffs

Der Hauptunterschied zwischen Git und anderen Versionsverwaltungssystemen (einschließlich Subversion und vergleichbaren Systemen) besteht in der Art und Weise, wie Git Daten betrachtet.
Die meisten anderen Systeme speichern Informationen als eine Liste von dateibasierten Änderungen (Diffs genannt).
Diese Systeme (CVS, Subversion, Perforce, Bazaar usw.) betrachten die Informationen, die sie verwalten, als eine Menge von Dateien und die Änderungen, die über die Zeit hinweg an einzelnen Dateien vorgenommen werden.

.Daten als Änderungen zu einer Basisversion einer Datei.
image::images/deltas.png[Daten als Änderungen zu einer Basisversion einer Datei.]

Git sieht und speichert Daten nicht auf diese Weise.
Stattdessen betrachtet Git seine Daten eher als eine Reihe von Snapshots eines Mini-Dateisystems.
Bei jedem Commit in Git (also der Speicherung des gegenwärtigen Status deines Projekts), sichert Git den Zustand sämtlicher Dateien in diesem Moment als Snapshot und speichert eine Referenz auf diesen.
Um effizient zu sein, kopiert Git unveränderte Dateien nicht, sondern legt lediglich eine Verknüpfung zu der vorherigen Version der Datei an.
Git betrachtet Daten also eher wie einen *Stream aus Snapshots*.

.Daten als Snapshots des Projekts über die Zeit.
image::images/snapshots.png[Git speichert Daten als Snapshots des Projekts über die Zeit.]

Dies ist ein wichtiger Unterschied zwischen Git und praktisch allen anderen Versionsverwaltungssystemen.
In Git wurden daher fast alle Aspekte der Versionsverwaltung neu überdacht, die andere Systeme mehr oder weniger von ihren jeweiligen Vorgängergenerationen übernommen haben.
Dies macht Git eher zu einem Mini-Dateisystem (das mit einigen unglaublich mächtigen Werkezeugen ausgerüstetet ist), als zu einem gängigen Versionsverwaltungssystem.
Auf einige der Vorteile, die es mit sich bringt, Daten in dieser Weise zu betrachten, werden wir in <<_git_branching>> eingehen, wenn wir das Git Branching Konzept diskutieren.

==== Beinahe jede Operation ist lokal

Die meisten Operationen in Git benötigen nur die lokalen Dateien und Ressourcen, um zu funktionieren – im Allgemeinen werden somit keine Informationen von einem anderen Rechner im Netzwerk benötigt.
Wenn man an ein CVCS gewöhnt ist, bei dem es bei den meisten Operationen zu Wartezeiten aufgrund von Latenzen im Netzwerk kommt, dann wird man glauben, dass die Götter der Geschwindigkeit Git mit unaussprechlichen Fähigkeiten ausgestattet haben.
Weil man die vollständige Projekthistorie auf der lokalen Festplatte hat, werden die allermeisten Operationen ohne jede Verzögerung ausgeführt.

Um beispielsweise die Historie des Projektes zu durchsuchen, braucht Git sie nicht von einem externen Server zu holen – es liest sie einfach aus der lokalen Datenbank.
Dies bedeutet, dass man die vollständige Projekthistorie beinahe ohne jede Verzögerung einsehen kann.
Wenn man nun sehen möchte, worin sich die aktuelle Version einer Datei von einer Version aus dem letzten Monat unterscheidet, dann wird Git diese Versionen lokal nachschlagen und ihre Unterschiede lokal bestimmen – Git muss zu diesem Zweck weder einen externen Server bitten, dies zu tun, noch muss es eine ältere Version von diesem Server laden, um die Aufgabe lokal zu erledigen.

Im Umkehrschluss bedeutet dies natürlich außerdem, dass es kaum etwas gibt, was man nicht offline oder ohne VPN-Zugang erledigen kann.
Wenn man im Flugzeug oder im Zug ein wenig arbeiten möchte, kann man seine Arbeit glücklicherweise weiter committen und sie erst dann auf den Server pushen (hochladen), wenn man wieder mit dem Internet verbunden ist.
Wenn man zu Hause ist, aber seinen VPN-Client nicht zum Laufen bekommt, kann man dennoch weiter arbeiten.
In vielen anderen Systemen ist dies entweder unmöglich oder sehr schwierig.
Beispielsweise erlaubt es Perforce nicht, sonderlich viel zu tun, solange man nicht mit dem Server verbunden ist; und bei Subversion und CVS kann man Dateien zwar ändern, die Änderungen aber nicht in der Datenbank sichern (weil die Datenbank offline ist).
Auch wenn es auf den ersten Blick keine große Sache zu sein scheint, wird man überrascht sein, welch großen Unterschied dies ausmachen kann.

==== Git bewahrt Integrität

Von allen in Git verwalteten Dateien wird eine Prüfsumme (englisch _Checksum_) erstellt, bevor sie gespeichert werden; die Prüfsumme dient als Verweis auf die Dateien.
Es ist damit praktisch unmöglich, die Inhalte irgendeiner Datei zu ändern, ohne dass Git dies bemerkt.
Git basiert auf dieser Funktionalität, die untrennbar zur Philosophie von Git gehört.
Daher können weder Informationen während einer Übermittlung verloren gehen, noch Dateien beschädigt werden, ohne dass Git dies feststellt.

Git verwendet SHA-1 als Hashfunktion zur Erstellung der Prüfsumme.(((SHA-1)))
Diese stellt sich dar als 40 Zeichen lange Hexadezimalzahl und wird von Git aus den Inhalten einer Datei oder Verzeichnisstruktur berechnet. Ein mit SHA-1 generierter Hash sieht etwa wie folgt aus:

[source]
----
24b9da6552252987aa493b52f8696cd6d3b00373
----

Solchen Hashwerten wird man überall in Git begegnen, weil sie so ausgiebig von Git verwendet werden.
Tatsächlich speichert Git sämtliche Informationen nicht nach Dateinamen, sondern nach dem Hashwert ihrer Inhalte in seiner Datenbank.

==== Git fügt meist nur Daten hinzu

Bei fast allen Operationen in Git werden lediglich Daten zur Git-Datenbank hinzugefügt.
Es ist schwierig, das System dazu zu bringen etwas zu tun, das nicht rückgängig gemacht werden kann oder irgendwie Daten zu löschen. 

Wie in jedem anderen Versionsverwaltungssystem kann man Änderungen verlieren oder kaputtmachen, die noch nicht committet wurden; doch wurde ein Snapshot ersteinmal committet, kann man ihn kaum mehr verlieren. Besonders dann nicht, wenn man seine Datenbank regelmäßig in ein anderes Repository pusht.

Die Verwendung von Git wird dadurch zum Vergnügen. Man kann einfach gewiss sein, dass man beim Herumexperimentieren nichts ernstaft zerstören kann.

Für tiefergehende Informationen dazu, wie Git seine Daten speichert und wie man scheinbar verloren geglaubte Daten wiederherstellen kann, siehe <<_undoing>>.

==== Die drei Zustände

Nun aufgepasst. 
Es folgt das Wichtigste, das man sich über Git merken muss, wenn man möchte, dass der weitere Lernprozess reibungslos verläuft.
Git besitzt drei Hauptzustände, in welchen sich Dateien befinden können: committed, modified und staged. 

Git definiert drei Haupt-Zustände, in denen sich eine Datei befinden kann: committed, modified („geändert“) und staged („vorgemerkt“). „Committed“ bedeutet, dass die Daten in der lokalen Datenbank gesichert sind. „Modified“ bedeutet, dass die Datei geändert, diese Änderung aber noch nicht committed wurde. „Staged“ bedeutet, dass Du eine geänderte Datei in ihrem gegenwärtigen Zustand für den nächsten Commit vorgemerkt hast.

Git has three main states that your files can reside in: committed, modified, and staged.
Committed means that the data is safely stored in your local database.
Modified means that you have changed the file but have not committed it to your database yet.
Staged means that you have marked a modified file in its current version to go into your next commit snapshot.

This leads us to the three main sections of a Git project: the Git directory, the working tree, and the staging area.

.Working tree, staging area, and Git directory.
image::images/areas.png["Working tree, staging area, and Git directory."]

The Git directory is where Git stores the metadata and object database for your project.
This is the most important part of Git, and it is what is copied when you clone a repository from another computer.

The working tree is a single checkout of one version of the project.
These files are pulled out of the compressed database in the Git directory and placed on disk for you to use or modify.

The staging area is a file, generally contained in your Git directory, that stores information about what will go into your next commit.
It's sometimes referred to as the ``index'', but it's also common to refer to it as the staging area.

The basic Git workflow goes something like this:

1. You modify files in your working tree.
2. You stage the files, adding snapshots of them to your staging area.
3. You do a commit, which takes the files as they are in the staging area and stores that snapshot permanently to your Git directory.

If a particular version of a file is in the Git directory, it's considered committed.
If it has been modified and was added to the staging area, it is staged.
And if it was changed since it was checked out but has not been staged, it is modified.
In <<_git_basics_chapter>>, you'll learn more about these states and how you can either take advantage of them or skip the staged part entirely.
