=== Änderungen am Repository nachverfolgen
 
Man verfügt nun über ein funktionierendes Git-Repository und über eine Arbeitskopie der Dateien dieses Projekts.
Nun müssen einige Änderungen vorgenommen und Snapshots dieser Änderungen jedes Mal in das Repository committet werden, wenn das Projekt einen Zustand erreicht hat, den man aufzeichnen möchte.

Wie bereits erwähnt, kann sich jede Datei im Arbeitsverzeichnis in einem von zwei Zuständen befinden: versioniert (englisch _tracked_, wird verfolgt) oder unversioniert (englisch _untracked_, wird nicht verfolgt).
Als versioniert gelten Dateien dann, wenn sie sich im letzten Snapshot befanden; diese Dateien können sich wiederum in den Zuständen unverändert (englisch _unmodified_), geändert (englisch _modified_) oder zum Commit vorgesehen (englisch _staged_) befinden.
Unversionierte Dateien sind alle anderen - Dateien, die sich nicht im letzten Snapshot befanden und die sich nicht in der Staging Area befinden.
Wenn man ein Repository zum ersten Mal klont, werden alle Dateien versioniert und unverändert sein, da Git sie gerade erst ausgecheckt hat und sie zu dem Zeitpunkt noch nicht geändert wurden.

Nimmt man dann Änderungen an ihnen vor, erkennt Git sie als geändert, da man sie seit dem letzten Commit bearbeitet wurden.
Man staged diese Dateien und committet schließlich die zum Commit vorgesehenen Dateien und der Kreislauf beginnt von Neuem.

.Der Lebenszyklus der Status von Dateien.
image::images/lifecycle.png[Der Lebenszyklus der Status von Dateien.]

[[_checking_status]]
==== Den Zustand von Dateien prüfen

Der wichtigste Befehl, den man nutzt, um herauszufinden, in welchem Status sich Dateien befinden, lautet `git status`.(((git commands, status)))
Führt man diesen Befehl unmittelbar nach dem Klonen eines Repositorys aus, sollte die Ausgabe in etwa wie folgt aussehen:

[source,console]
----
$ git status
Auf Branch master
Ihr Branch ist auf dem selben Stand wie 'origin/master'.
nichts zu committen, Arbeitsverzeichnis unverändert
----

Das bedeutet, dass das Arbeitsverzeichnis unverändert (englisch _clean_) ist; es wurden also noch keine der versionierten Dateien verändert.
Ebenso wenig erkannte Git irgendwelche unversionierten Dateien, sonst wären sie hier aufgelistet worden.
Schließlich teilt einem die Ausgabe des Befehls noch mit, auf welchem Entwicklungszweig (englisch _Branch_) man sich befindet und dass dieser noch nicht vom gleichnamigen Branch auf dem Server divergiert ist, die Inhalte also nicht von denen auf dem Server abweichen.
Der Name des Branches, auf dem man sich befindet, lautet ``master''. Dies ist der Standard und für den Anfang in Ordnung.
In <<_git_branching>> werden Branches und Referenzen näher erläutert werden.

Angenommen, man fügt als neue Datei eine einfache README-Datei zum Projekt hinzu und führt den Befehl `git status` aus, dann führt dies zur Auflistung der unversionierten Datei, da diese vorher ja noch nicht existierte:

[source,console]
----
$ echo 'Mein Projekt' > README
$ git status
Auf Branch master
Ihr Branch ist auf dem selben Stand wie 'origin/master'.
Unversionierte Dateien:
  (benutzen Sie "git add <Datei>...", um die Änderungen zum Commit vorzumerken)

	README

nichts zum Commit vorgemerkt, aber es gibt unversionierte Dateien (benutzen Sie "git add" zum Versionieren)
----

Unter der Überschrift ``Unversionierte Dateien'' taucht nun die neu erstellte README-Datei auf.
Unversioniert meint grundsätzlich, dass Git eine Datei erkannt hat, die sich nicht in einem der bisher erstellten Snapshots (Commit) befand; Git wird diese auch nicht automatisch in die Versionierung aufnehmen, bis man Git explizit dazu auffordert.
Dieses Verhalten sorgt dafür, dass man nicht aus Versehen generierte Binärdateien oder andere Dateien aufnimmt, die man nicht dafür vorgesehen hatte.
Im Beispiel möchte man die README-Datei aber hinzufügen, also wird die Datei unter die Versionsverwaltung gestellt.

[[_tracking_files]]
==== Neue Dateien versionieren

Um eine neue Datei zu versionieren, nutzt man das Kommando `git add`.(((git commands, add)))
Für die README-Datei im Beispiel heißt dies also, dass man folgenden Befehl ausführt:

[source,console]
----
$ git add README
----

Führt man anschließend erneut den Status-Befehl aus, wird die README-Datei als versioniert und für den nächsten Commit vorgesehen (staged) angezeigt:

[source,console]
----
$ git status
Auf Branch master
Ihr Branch ist auf dem selben Stand wie 'origin/master'.
zum Commit vorgemerkte Änderungen:
  (benutzen Sie "git reset HEAD <Datei>..." zum Entfernen aus der Staging-Area)

	neue Datei:     README

----

Die Datei wird nun unter der Überschrift ``zum Commit vorgemerkte Änderungen'' aufgelistet, was bedeutet, dass sie nun gestaged ist.
Führt man jetzt einen Commit durch, wird die Datei in der Version zur Historie hinzugefügt, die sie nach dem Ausführen von `git add` hatte.
Beim Initialisieren des Git-Repositorys mit `git init` im früheren Beispiel wurde darauf der Befehl `git add (Dateien)` ausgeführt - womit die Dateien zur Versionierung hinzugefügt wurden.(((git commands, init)))(((git commands, add)))
Der Befehl `git add` nimmt eine Pfadangabe entgegen sowohl für eine Datei, als auch für ein Verzeichnis; gibt man ein Verzeichnis an, so fügt der Befehl alle Dateien unterhalb des angegebenen Pfades rekursiv hinzu.

==== Geänderte Dateien zum Commit vormerken (Staging)

Als Nächstes soll eine Datei geändert werden, die bereits versioniert ist.
Ändert man die bereits getrackte Datei `CONTRIBUTING.md` und ruft anschließend erneut `git status` auf, bekommt man das folgende Ergebnis:

[source,console]
----
$ git status
Auf Branch master
zum Commit vorgemerkte Änderungen:
  (benutzen Sie "git reset HEAD <Datei>..." zum Entfernen aus der Staging-Area)

	neue Datei:     README

Änderungen, die nicht zum Commit vorgemerkt sind:
  (benutzen Sie "git add <Datei>...", um die Änderungen zum Commit vorzumerken)
  (benutzen Sie "git checkout -- <Datei>...", um die Änderungen im Arbeitsverzeichnis zu verwerfen)

	geändert:       CONTRIBUTING.md

----

Die Datei `CONTRIBUTING.md` erscheint nun im Bereich ``Änderungen, die nicht zum Commit vorgemerkt sind``. Das bedeutet, dass eine versionierte Datei im Arbeitsverzeichnis verändert wurde, aber noch nicht gestaged wurde.
Um die Datei zu stagen, führt man den Befehl `git add` aus.
`git add` ist ein Mehrzweck-Befehl - man nutzt ihn, um neue Dateien der Versionsverwaltung hinzuzufügen, Dateien zu stagen, und andere Dinge, wie z.B. einen Merge-Konflikt einer Datei als beseitigt zu erklären.
Es könnte hilfreich sein, den Befehl eher mit ``füge diesen Inhalt dem nächsten Commit hinzu'', als mit ``füge die Datei dem Projekt hinzu'' zu übersetzen.(((git commands, add)))
Nun soll `git add` ausgeführt werden, um die Datei `CONTRIBUTING.md` der Staging Area hinzuzufügen. Gleich anschließend wird wieder `git status` aufgerufen:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
Auf Branch master
zum Commit vorgemerkte Änderungen:
  (benutzen Sie "git reset HEAD <Datei>..." zum Entfernen aus der Staging-Area)

	geändert:       CONTRIBUTING.md
	neue Datei:     README

----

Beide Dateien sind nun für den nächsten Commit vorgesehen.
Angenommen, man möchte just in diesem Moment eine weitere kleine Änderung an
`CONTRIBUTING.md` vornehmen, bevor man sie committet.
Also öffnet man die Datei, führt die Änderung durch, und ist bereit für den Commit.
Schaut man sich dann die Ausgabe von `git status` noch einmal an, erhält man Folgendes:

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
Auf Branch master
zum Commit vorgemerkte Änderungen:
  (benutzen Sie "git reset HEAD <Datei>..." zum Entfernen aus der Staging-Area)

	geändert:       CONTRIBUTING.md
	neue Datei:     README

Änderungen, die nicht zum Commit vorgemerkt sind:
  (benutzen Sie "git add <Datei>...", um die Änderungen zum Commit vorzumerken)
  (benutzen Sie "git checkout -- <Datei>...", um die Änderungen im Arbeitsverzeichnis zu verwerfen)

	geändert:       CONTRIBUTING.md

----

Ja, hoppla! Was ist denn das?
Nun wird `CONTRIBUTING.md` sowohl als staged, als auch unstaged gelistet.
Wie ist das möglich?
Es zeigt sich, dass Git die Datei genau in der Version in die Staging Area übernimmt, die sie zum Zeitpunkt hatte, als `git add` ausgeführt wurde.
Führt man jetzt den Commit mit `git commit` aus, wird also nur diese Version von `CONTRIBUTING.md` in die Historie übernommen und nicht die Version, die sich nach der Änderung im Arbeitsverzeichnis befindet.
Deshalb muss man `git add` erneut ausführen, um die neueste Version der Datei für den Commit vorzumerken:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
Auf Branch master
zum Commit vorgemerkte Änderungen:
  (benutzen Sie "git reset HEAD <Datei>..." zum Entfernen aus der Staging-Area)

	geändert:       CONTRIBUTING.md
	neue Datei:     README

----

==== Kurze Status-Ausgabe

Die Ausgabe von `git status` ist sehr umfassend und damit auch recht weitschweifig.
Um eine kompaktere Ausgabe zu erhalten, besitzt Git einen Schalter zur Kurzdarstellung der Status-Ausgabe.
Um zu dieser vereinfachten Ausgabe zu gelangen, führt man `git status -s` oder `git status --short` aus:

[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

Neue unversionierte Dateien sind mit `??`, neue Dateien in der Staging Area mit `A`, geänderte Dateien mit `M` und so weiter gekennzeichnet.
Die Kennzeichnung ist zweispaltig aufgebaut - die linke Spalte zweigt den Status in der Staging Area an, die rechte den Status im Arbeitsverzeichnis.
In der obigen Ausgabe wurde also `README` im Arbeitsverzeichnis geändert, befindet sich aber noch nicht in der Staging Area, wohingegen `lib/simplegit.rb` als geändert und staged gekennzeichnet ist.
`Rakefile` wurde geändert, gestaged und wieder geändert; es gibt also Änderungen, die sowohl gestaged als auch unstaged sind.

[[_ignoring]]
==== Dateien ignorieren

Es kommt häufig vor, dass es Klassen von Dateien im Arbeitsverzeichnis gibt, die man weder automatisch zu Git hinzufügen, noch als nicht versionierte Dateien angezeigt bekommen möchte.
Diese sind oft automatisch erstellte Dateien, wie Logfiles, oder durch ein Build-System erzeugte Dateien.
Für diese Fälle kann man eine Datei `.gitignore` erstellen, die Dateimuster für diese auszuschließenden Dateien enthält.(((ignoring files)))
Hier ist ein Beispiel für eine `.gitignore`-Datei:

[source,console]
----
$ cat .gitignore
*.[oa]
*~
----

Die erste Zeile teilt Git mit, dass es alle Dateien mit den Endungen ``.o'' or ``.a'' ignorieren soll - Objekt- oder Archivdateien, die bei der Erzeugung von Code durch ein Build-System entstehen können.
Die zweite Zeile weist Git an, alle Dateien auszuschließen, die mit einer Tilde (`~`) enden; solche werden von vielen Texteditoren wie Emacs als temporäre Dateien erstellt.
Man kann auch Verzeichnisse wie log, tmp oder pid, automatisch generierte Dokumentationen, usw. in die Liste übernehmen.
Es ist also grundsätzlich eine gute Idee, eine `.gitignore`-Datei anzulegen, bevor man loslegt, damit man nicht versehentlich Dateien committet, die man wirklich nicht in seinem Git-Repository haben möchte.

Die Regeln für die Muster, die man in der `.gitignore`-Datei verwenden kann, sind wie folgt:

*	Leere Zeilen oder Zeilen, die mit `#` beginnen, werden ignoriert.
*	Standardmäßige `glob`-Muster funktionieren.
*	Man kann ein Muster mit einem Schrägstrich (`/`) abschließen, um ein Verzeichnis zu deklarieren.
*	Man kann ein Muster negieren, indem man ein Ausrufezeichen (`!`) voranstellst.

Glob-Muster sind vereinfachte reguläre Ausdrücke, die von Shells verwendet werden. Ein Stern (`*`) entspricht keinem oder mehreren Zeichen; `[abc]` greift bei einem der in den eckigen Klammern angegebenen Zeichen (in diesem Fall also a, b oder c); ein Fragezeichen (`?`) bezeichnet ein beliebiges, einzelnes Zeichen; und eckige Klammern mit Zeichen, die von einem Bindestrich getrennt werden (`[0-9]`) bezeichnen ein Zeichen aus der angegebenen Menge von Zeichen (in diesem Fall also ein Zeichen zwischen 0 und 9).

Man kann auch zwei Sterne benutzen, um verschachtelte Verzeichnisse zu bezeichnen; `a/**/z` würde also auf `a/z`, `a/b/z`, `a/b/c/z` und so weiter zutreffen.

Ein weiteres Beispiel für eine `.gitignore`-Datei:

[source]
----
# ignoriere alle Dateien, die mit .a enden
*.a

# lib.a wird nicht ignoriert, obwohl andere auf .a endende Dateien durch die obige Regel ausgeschlossen werden
!lib.a

# ignoriere die Datei TODO im aktuellen Verzeichnis, nicht in subdir/TODO
/TODO

# ignoriere alle Dateien im Verzeichnis build/
build/

# ignoriere doc/notes.txt, doch nicht doc/server/arch.txt
doc/*.txt

# ignoriere alle auf .pdf endenden Dateien im Verzeichnis doc/ und in jedem seiner Unterverzeichnisse
doc/**/*.pdf
----

[TIP]
====
GitHub pflegt eine recht umfangreiche Liste von brauchbaren Beispielen für `.gitignore`-Dateien für dutzende Projekte und Sprachen unter https://github.com/github/gitignore[], falls man einen Startpunkt für sein Projekt benötigt.
====

[[_git_diff_staged]]
==== Änderungen in und außerhalb der Staging Area betrachten

Falls einem die Ausgabe des `git status`-Befehls zu vage ist, - man möchte vielleicht wissen, was man geändert hat, nicht nur, welche Dateien geändert wurden - kann man den Befehl `git diff` nutzen.(((git commands, diff)))
Der `git diff`-Befehl wird später noch im Detail genauer betrachtet werden, aber man mag es am häufigsten verwenden, um zwei Fragen zu beantworten: "Was wurde geändert, aber noch nicht gestaged?" und "Was wurde gestaged und damit für den nächsten Commit vorgesehen?"
Obschon `git status` diese Fragen sehr allgemein beantwortet, indem es die Dateinamen ausgibt, zeigt `git diff` exakt die Zeilen, die hinzugefügt und entfernt wurden - es zeigt gewissermaßen einen Patch.

Angenommen, dass die Datei README erneut geändert und gestaged wurde und danach die Datei `CONTRIBUTING.md` geändert wurde, ohne diese zu stagen.
Führt man nun `git status` aus, bekommt man wieder eine Ausgabe wie folgt:

[source,console]
----
$ git status
Auf Branch master
zum Commit vorgemerkte Änderungen:
  (benutzen Sie "git reset HEAD <Datei>..." zum Entfernen aus der Staging-Area)

	geändert:       README

Änderungen, die nicht zum Commit vorgemerkt sind:
  (benutzen Sie "git add <Datei>...", um die Änderungen zum Commit vorzumerken)
  (benutzen Sie "git checkout -- <Datei>...", um die Änderungen im Arbeitsverzeichnis zu verwerfen)

	geändert:       CONTRIBUTING.md

----

Um zu sehen, was man geändert, aber noch nicht gestaged hat, führt man den Befehl `git diff` ohne weitere Argumente aus:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

Der Befehl vergleicht die Datei aus dem Arbeitsverzeichnis mit der aus der Staging Area.
Das Ergebnis zeigt die Unterschiede an, die bislang noch nicht gestaged wurden.

Möchte man sehen, was man gestaged hat und was somit für den nächsten Commit vorgemerkt ist, kann man den Befehl `git diff --staged` ausführen.
Er vergleicht die Änderungen in der Staging Area mit dem letzten Commit:

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
----

Es ist wichtig anzumerken, dass `git diff` selbst nicht alle Änderungen anzeigt, die seit dem letzten Commit durchgeführt wurden - lediglich Änderungen, die noch nicht gestaged wurden.
Das kann etwas verwirrend sein, denn wenn man alle Änderungen gestaged hat, dann wird `git diff` keine Ausgabe erzeugen.



For another example, if you stage the `CONTRIBUTING.md` file and then edit it, you can use `git diff` to see the changes in the file that are staged and the changes that are unstaged.
If our environment looks like this:

[source,console]
----
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Now you can use `git diff` to see what is still unstaged:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
----

and `git diff --cached` to see what you've staged so far (`--staged` and `--cached` are synonyms):

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTE]
.Git Diff in an External Tool
====
We will continue to use the `git diff` command in various ways throughout the rest of the book.
There is another way to look at these diffs if you prefer a graphical or external diff viewing program instead.
If you run `git difftool` instead of `git diff`, you can view any of these diffs in software like emerge, vimdiff and many more (including commercial products).
Run `git difftool --tool-help` to see what is available on your system.
====

[[_committing_changes]]
==== Committing Your Changes

Now that your staging area is set up the way you want it, you can commit your changes.
Remember that anything that is still unstaged – any files you have created or modified that you haven't run `git add` on since you edited them – won't go into this commit.
They will stay as modified files on your disk.
In this case, let's say that the last time you ran `git status`, you saw that everything was staged, so you're ready to commit your changes.(((git commands, status)))
The simplest way to commit is to type `git commit`:(((git commands, commit)))

[source,console]
----
$ git commit
----

Doing so launches your editor of choice.
(This is set by your shell's `$EDITOR` environment variable – usually vim or emacs, although you can configure it with whatever you want using the `git config --global core.editor` command as you saw in <<_getting_started>>).(((editor, changing default)))(((git commands, config)))

The editor displays the following text (this example is a Vim screen):

[source]
----

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

You can see that the default commit message contains the latest output of the `git status` command commented out and one empty line on top.
You can remove these comments and type your commit message, or you can leave them there to help you remember what you're committing.
(For an even more explicit reminder of what you've modified, you can pass the `-v` option to `git commit`.
Doing so also puts the diff of your change in the editor so you can see exactly what changes you're committing.)
When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out).

Alternatively, you can type your commit message inline with the `commit` command by specifying it after a `-m` flag, like this:

[source,console]
----
$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

Now you've created your first commit!
You can see that the commit has given you some output about itself: which branch you committed to (`master`), what SHA-1 checksum the commit has (`463dc4f`), how many files were changed, and statistics about lines added and removed in the commit.

Remember that the commit records the snapshot you set up in your staging area.
Anything you didn't stage is still sitting there modified; you can do another commit to add it to your history.
Every time you perform a commit, you're recording a snapshot of your project that you can revert to or compare to later.

==== Skipping the Staging Area

(((staging area, skipping)))
Although it can be amazingly useful for crafting commits exactly how you want them, the staging area is sometimes a bit more complex than you need in your workflow.
If you want to skip the staging area, Git provides a simple shortcut.
Adding the `-a` option to the `git commit` command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the `git add` part:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
----

Notice how you don't have to run `git add` on the `CONTRIBUTING.md` file in this case before you commit.
That's because the `-a` flag includes all changed files.
This is convenient, but be careful; sometimes this flag will cause you to include unwanted changes.

[[_removing_files]]
==== Removing Files

(((files, removing)))
To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit.
The `git rm` command does that, and also removes the file from your working directory so you don't see it as an untracked file the next time around.

If you simply remove the file from your working directory, it shows up under the ``Changed but not updated'' (that is, _unstaged_) area of your `git status` output:

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

Then, if you run `git rm`, it stages the file's removal:

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

The next time you commit, the file will be gone and no longer tracked.
If you modified the file and added it to the staging area already, you must force the removal with the `-f` option.
This is a safety feature to prevent accidental removal of data that hasn't yet been recorded in a snapshot and that can't be recovered from Git.

Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area.
In other words, you may want to keep the file on your hard drive but not have Git track it anymore.
This is particularly useful if you forgot to add something to your `.gitignore` file and accidentally staged it, like a large log file or a bunch of `.a` compiled files.
To do this, use the `--cached` option:

[source,console]
----
$ git rm --cached README
----

You can pass files, directories, and file-glob patterns to the `git rm` command.
That means you can do things such as:

[source,console]
----
$ git rm log/\*.log
----

Note the backslash (`\`) in front of the `*`.
This is necessary because Git does its own filename expansion in addition to your shell's filename expansion.
This command removes all files that have the `.log` extension in the `log/` directory.
Or, you can do something like this:

[source,console]
----
$ git rm \*~
----

This command removes all files whose names end with a `~`.

[[_git_mv]]
==== Moving Files

(((files, moving)))
Unlike many other VCS systems, Git doesn't explicitly track file movement.
If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file.
However, Git is pretty smart about figuring that out after the fact – we'll deal with detecting file movement a bit later.

Thus it's a bit confusing that Git has a `mv` command.
If you want to rename a file in Git, you can run something like:

[source,console]
----
$ git mv file_from file_to
----

and it works fine.
In fact, if you run something like this and look at the status, you'll see that Git considers it a renamed file:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

However, this is equivalent to running something like this:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

Git figures out that it's a rename implicitly, so it doesn't matter if you rename a file that way or with the `mv` command.
The only real difference is that `git mv` is one command instead of three – it's a convenience function.
More importantly, you can use any tool you like to rename a file, and address the add/rm later, before you commit.
